"""
This file contains routines used to read in data from the SHIELDS-PTM particle tracing
simulation as well as to calculate quantities based on the particle data.

Jesse Woodroffe
last revised 6/2/2016
"""

from numpy import array,size,sqrt,pi,exp,loadtxt,argwhere,sort,unique,zeros,zeros_like,sin,cos,arctan2,log10,r_
from scipy import special

def parse_ptm_file(fname):
    """
    This routine reads a file of particle trajectory data generated by the ptm simulation. Data from ptm is
    output in formatted ascii, with the time history of a particle trajectory given by a 8-column array with
    an unknown number of rows. The data from each particle is separated by a "#".

    TIME XPOS YPOS ZPOS VPERP VPARA ENERGY PITCHANGLE
    
    Results from this routine are returned as a dictionary with the trajectory of each particle stored under
    a separate integer key (0-based indexing: first particle is 0, second is 1, etc.)

    Jesse Woodroffe
    11/18/2015
    """
    with open(fname,'r') as f:
        flines=f.readlines()
    res=''.join(flines).replace('\n',' ').split(' # ')
    ncol=size(flines[0].strip('\n').lstrip().split('  '))
    dataDict={}
    for i,s in enumerate(res):
        dataVec=array(map(float,s.replace('   ','  ').lstrip().split('  ')))
        dataDict[i]=dataVec.reshape((size(dataVec)/ncol,ncol))
    return dataDict

def parse_map_file(fname):
  """
  This is a convenience routine to read in a "map" file generated by the PTM simulation. Since the particles
  aren't output in a logical or predictable manner, this routine also assembles the energy--pitch-angle grids
  and returns the results in a dictionary. This is all the information that is needed from SHIELDS-PTM to
  assemble flux maps using the energy_to_flux routine.
  
  Jesse Woodroffe
  5/23/2016
  """
  
  res = loadtxt(fname)
  
  pavec = sort(unique(res[:,-2]))
  envec = sort(unique(res[:,-3]))
  
  fluxmap={}
  fluxmap['energies']=envec
  fluxmap['angles']=pavec
  
  Einit = zeros([envec.size,pavec.size])
  Efinal = zeros_like(Einit)
  
  for icount in xrange(size(res,0)):
    idex = argwhere(res[icount,-3]==envec)
    jdex = argwhere(res[icount,-2]==pavec)
    Einit[idex,jdex]=res[icount,-3]
    Efinal[idex,jdex]=res[icount,-1]
  
  fluxmap['init_E']=Einit
  fluxmap['final_E']=Efinal 
  
  return fluxmap

def energy_to_flux(ei,ef,ec,n,mc2=511.0,kind='kappa',kap=2.5):
    """
    Given the particle energy, number density of particles, and characteristic energy of the distribution,
    calculate the differential energy flux in keV-1 cm-2 s-1 sr-1. 
    
    If you are performing backwards tracing from GEO to some point in the tail, Ei is the energy in the tail
    and Ef is the energy at GEO.
    
    Required Inputs are:
      Ei    Initial energy (energy in source region) in keV
      Ef    Final energy (energy at observation point) in keV
      Ec    Characteristic energy of the distribution in keV (analogous to temperature)
      n     Density of particles in cm-3
    
    Optional inputs are:
      mc2   Mass energy of the particle species in keV (default is 511 for electrons)
      kind  Kind of distribution function to use
            'kappa'     kappa distribution in energy
            'maxwell'   relativistic Maxwell-Juttner distribution
      kap   Power law index for the kappa distribution (default is 2.5)
    
    The default value of kappa corresponds to electrons in a fairly strong substorm. For other species and
    levels of activity, Gabrielse et al. [2014] provided a table of values for kappa, derived from THEMIS
    observations:
    
      |AL|    ions    electrons
      min     5.1     2.7
      int     4.6     2.7
      max     4.4     2.5
    
    Values of n and Ec need to be obtained from some sort of tail plasma model, either kinetic or
    MHD (in which case Ec~P/rho). It is also important to remember that electron temperature usually
    differs from ion temperature, up to a factor of 7 different. It is up to the user to make sure
    that the correct temperature for the desired species is provided.
    
    Jesse Woodroffe
    3/30/2016
    """
    
    ckm=2.998e5
    gami=1+ei/mc2
    gamc=1+ec/mc2
    gamf=1+ef/mc2
    u=ckm*sqrt(gami*gami-1.0)/gami
    w=ckm*sqrt(gamc*gamc-1.0)/gamc
    v=ckm*sqrt(gamf*gamf-1.0)/gamf
    
    if(kind=='maxwell'):
      # Maxwell-Juttner distribution
      Q=ec/mc2
      f0=n/(4*pi*ckm**3*Q*special.kn(2,1.0/Q))
      f=f0*exp(-gami/Q)
    elif(kind=='kappa'):
      # Kappa distribution
      Wc=ec*(1.0-1.5/kap)
      wkc=gamc*w
      f0=n*(2*pi*kap*wkc*wkc)**-1.5*(special.gamma(kap+1)/special.gamma(kap-0.5))
      f=f0*(1+ei/(kap*Wc))**-(kap+1)
    else:
      raise Exception('Error in energy_to_flux: kind= '+kind+' is not supported')

    j=1e5*ckm*ckm*v*v/mc2*f

    return j
        
def tm03_moments(x,y,swD):
    """
    The Tsyganeko and Mukai [2003] plasma sheet model (with corrected equations).
    
    Inputs:
      x     GSM x position in Earth radii
      y     GSM y position in Earth radii
      swD   A dictionary with the following keys that must be defined:
          'bperp' Magnitude of the perpendicular component of the solar wind magnetic field in nT
          'theta' Solar wind clock angle in degrees
          'vx'    Solar wind speed in km/s
          'n'     Solar wind density in cm-3
          'p'     Solar wind dynamic pressure in nPa
          
    Outputs:
      res   A dictionary with the following keys:
          'P'   Local pressure in nPa
          'T'   Local temperature in keV
          'n'   Local ion/electron density in cm-3
          
    Reference:
    
    Tsyganeko, N. A. and T. Mukai (2003), Tail plasma sheet models derived from Geotail particle data,
        J. Geophys. Res., 108(A3),1136, doi:10.1029/2002JA009707
    
    The output from the TM03 model can be used to set n and Ec inputs to the energy_to_flux routine.
    
    Jesse Woodroffe
    6/2/2016
    """
    
    aT=r_[0,1.678,-0.1606, 1.669, 4.820,  2.855, -0.602, -0.836,-2.491,
          0.2568,0.2249,0.1887,-0.4458,-0.0331,-0.0241,-2.689, 1.222]
    aN=r_[0,-0.159,0.608,0.5055,0.0796,0.2746,0.0361,-0.0342,-0.7935,1.162,0.4756,0.7117]
    aP=r_[0,0.057,0.524,0.0908,0.527,0.078,-4.422,-1.533,
          -1.217, 2.54, 0.32,  0.754,1.048,-0.074, 1.015]
    dtor=pi/180.0
    bperp=swD['bperp']/5
    bz=swD['bperp']*cos(swD['theta']*dtor)
    if(bz>0):
        bzn=bz/5.0
        bzs=0.0
    else:
        bzn=0.0
        bzs=bz/5.0
    vsw=swD['vx']/500.0
    nsw=swD['n']/10.0
    fsw=bperp*sqrt(sin(swD['theta']*dtor/2))
    rho=sqrt(x*x+y*y)/10.0
    psw=swD['p']/3.0
    phi=-arctan2(y,x)
    rm1=rho-1.0
    T=(aT[1]*vsw+aT[2]*bzn+aT[3]*bzs+aT[4]*
       exp(-(aT[9]*vsw**aT[15]+aT[10]*bzn+aT[11]*bzs)*rm1)+
       (aT[5]*vsw+aT[6]*bzn+aT[7]*bzs+aT[8]*
        exp(-(aT[12]*vsw**aT[16]+aT[13]*bzn+aT[14]*bzs)*rm1))*sin(phi)**2)
    N=((aN[1]+aN[2]*nsw**aN[10]+aN[3]*bzn+aN[4]*vsw*bzs)*rho**aN[8]+
       (aN[5]*nsw**aN[11]+aN[6]*bzn+aN[7]*vsw*bzs)*rho**aN[9]*sin(phi)**2)
    P=(aP[1]*rho**aP[6]+aP[2]*psw**aP[11]*rho**aP[7]+aP[3]*fsw**aP[12]*rho**aP[8]+
       (aP[4]*psw**aP[13]*exp(-aP[9]*rho)+aP[5]*fsw**aP[14]*exp(-aP[10]*rho))*sin(phi)**2)
       
    res={'P':P,'T':T,'n':N}
    
    return res   